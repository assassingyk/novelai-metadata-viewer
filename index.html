<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">
    <script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <title>NovelAI metadata Viewer</title>
    <style>
        .textarea {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>

<body>
    <nav class="navbar is-primary" role="navigation" aria-label="main navigation">
        <div class="navbar-brand">
            <span class="navbar-item">
                <p class="title">NovelAI metadata Viewer v2.0.0</p>
            </span>
        </div>
        <div class="navbar-end">
            <div class="navbar-item">
                <div class="buttons is-grouped">
                    <a class="button is-light" href="https://novelai.net/" target="_blank" rel="noopener noreferrer">
                        NovelAI
                    </a>
                    <a class="button is-light" href="https://danbooru.donmai.us" target="_blank"
                        rel="noopener noreferrer">
                        Danbooru
                    </a>
                    <a class="button is-light" href="https://github.com/assassingyk/novelai-metadata-viewer"
                        target="_blank" rel="noopener noreferrer">
                        GitHub
                    </a>
                </div>
            </div>
        </div>
    </nav>
    <div id="app" @dragover.prevent @drop.prevent="onFileChange">
        <div class="container is-max-desktop">
            <div class="section">
                <p>This tool does NOT upload images to the server. It runs in your browser.</p>
                <div class="file is-boxed">
                    <label class="file-label">
                        <input class="file-input" type="file" name="resume" accept=".png" @change="onFileChange">
                        <span class="file-cta">
                            <span class="file-label">
                                Choose a file or drop image
                            </span>
                        </span>
                    </label>
                </div>
                <div class="columns">
                    <div class="column" v-if="isPNG && hasMetadata && isNAIMetadata">
                        <div v-if="v4_prompts.isV4">
                            <div class="field">
                                <label class="label">Base Prompt</label>
                                <div class="control">
                                    <textarea class="textarea" readonly :value="v4_prompts.base_prompt"
                                        rows="5"></textarea>
                                </div>
                            </div>
                             <div class="field">
                                <label class="label">Base Negative Prompt</label>
                                <div class="control">
                                    <textarea class="textarea" readonly :value="v4_prompts.base_negative_prompt"
                                        rows="5"></textarea>
                                </div>
                            </div>
                            <hr>
                            <div v-for="(char, index) in v4_prompts.characters" :key="index">
                                <h3 class="title is-4">Character {{ index + 1 }}</h3>
                                <div class="field">
                                    <label class="label">Character Prompt</label>
                                    <div class="control">
                                        <textarea class="textarea" readonly :value="char.prompt" rows="5"></textarea>
                                    </div>
                                </div>
                                <div class="field">
                                    <label class="label">Character Negative Prompt</label>
                                    <div class="control">
                                        <textarea class="textarea" readonly :value="char.negative_prompt" rows="1"></textarea>
                                    </div>
                                </div>
                                <div class="field">
                                    <label class="label">Character Position</label>
                                    <div class="control">
                                        <textarea class="textarea" readonly :value="char.position" rows="1"></textarea>
                                    </div>
                                </div>
                                <hr>
                            </div>
                        </div>

                        <div v-else>
                            <div class="field">
                                <label class="label">Raw Prompts</label>
                                <div class="control">
                                    <textarea class="textarea" placeholder="raw prompts" readonly :value="rawPrompts"
                                        rows="10"></textarea>
                                </div>
                            </div>
                             <div class="field">
                                <label class="label">uc</label>
                                <div class="control">
                                    <textarea class="textarea" placeholder="image uc" readonly :value="uc"
                                        rows="5"></textarea>
                                </div>
                            </div>
                        </div>

                        <div class="columns">
                            <div class="column">
                                <div class="field">
                                    <label class="label">Steps</label>
                                    <div class="control">
                                        <input class="input" type="text" placeholder="Text input" readonly
                                            :value="steps">
                                    </div>
                                </div>
                            </div>
                            <div class="column">
                                <div class="field">
                                    <label class="label">Height</label>
                                    <div class="control">
                                        <input class="input" type="text" placeholder="Text input" readonly
                                            :value="height">
                                    </div>
                                </div>
                            </div>
                            <div class="column">
                                <div class="field">
                                    <label class="label">Width</label>
                                    <div class="control">
                                        <input class="input" type="text" placeholder="Text input" readonly
                                            :value="width">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="columns">
                            <div class="column">
                                <div class="field">
                                    <label class="label">Sampler</label>
                                    <div class="control">
                                        <input class="input" type="text" placeholder="Image sampler" readonly
                                            :value="sampler">
                                    </div>
                                </div>
                            </div>
                            <div class="column">
                                <div class="field">
                                    <label class="label">Request type</label>
                                    <div class="control">
                                        <input class="input" type="text" placeholder="Request type" readonly
                                            :value="request_type">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="columns">
                            <div class="column">
                                <div class="field">
                                    <label class="label">Scale</label>
                                    <div class="control">
                                        <input class="input" type="text" placeholder="Text input" readonly
                                            :value="scale">
                                    </div>
                                </div>
                            </div>
                            <div class="column">
                                <div class="field">
                                    <label class="label">CFG rescale</label>
                                    <div class="control">
                                        <input class="input" type="text" placeholder="Text input" readonly
                                            :value="cfg_rescale">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="columns">
                            <div class="column">
                                <div class="field">
                                    <label class="label">SMEA</label>
                                    <div class="control">
                                        <input class="input" type="text" placeholder="SMEA on/off" readonly :value="sm">
                                    </div>
                                </div>
                            </div>
                            <div class="column">
                                <div class="field">
                                    <label class="label">DYN</label>
                                    <div class="control">
                                        <input class="input" type="text" placeholder="DYN on/off" readonly
                                            :value="sm_dyn">
                                    </div>
                                </div>
                            </div>
                            <div class="column">
                                <div class="field">
                                    <label class="label">Vibe Transfer</label>
                                    <div class="control">
                                        <input class="input" type="text" placeholder="vibe on/off" readonly
                                            :value="is_vibe">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="columns">
                            <div class="column">
                                <div class="field">
                                    <label class="label">Noise</label>
                                    <div class="control">
                                        <input class="input" type="text" placeholder="Text input" readonly
                                            :value="noise">
                                    </div>
                                </div>
                            </div>
                            <div class="column">
                                <div class="field">
                                    <label class="label">Strength</label>
                                    <div class="control">
                                        <input class="input" type="text" placeholder="Text input" readonly
                                            :value="strength">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="field">
                            <label class="label">Seed</label>
                            <div class="control">
                                <input class="input" type="text" placeholder="Text input" readonly :value="seed">
                            </div>
                        </div>
                       
                        <div class="columns">
                            <div class="column">
                                <div class="field">
                                    <label class="label">Software</label>
                                    <div class="control">
                                        <input class="input" type="text" placeholder="Image software" readonly
                                            :value="software">
                                    </div>
                                </div>
                            </div>
                            <div class="column">
                                <div class="field">
                                    <label class="label">Source</label>
                                    <div class="control">
                                        <input class="input" type="text" placeholder="image source" readonly
                                            :value="source">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="field">
                            <label class="label">Title</label>
                            <div class="control">
                                <input class="input" type="text" placeholder="Image title" readonly :value="title">
                            </div>
                        </div>
                    </div>
                    <div class="column" v-if="!isPNG">
                        <p class="subtitle">This image is not a PNG file!</p>
                    </div>
                    <div class="column" v-if="isPNG && !hasMetadata">
                        <p class="subtitle">This image doesn't seem to have metadata!</p>
                    </div>
                    <div class="column" v-if="isPNG && hasMetadata && !isNAIMetadata">
                        <p class="subtitle">This image has metadata, but doesn't seem to be created with NovelAI!</p>
                        <div class="field">
                            <label class="label">raw metadata</label>
                            <div class="control">
                                <textarea class="textarea" placeholder="raw metadata" readonly :value="rawmetadata"
                                    rows="20"></textarea>
                            </div>
                        </div>
                    </div>
                    <div class="column">
                        <img id="preview" v-if="preview" :src="preview">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer class="footer">
        <div class="content has-text-centered ">
            <p>
                This tool is not related to NovelAI<br>
                <a href="https://github.com/rassi0429/novelai-metadata-viewer">GitHub (welcome PR,issues)</a>
                The website content is licensed Apache 2.0 License.
            </p>
        </div>
    </footer>
    <script>
        class DataReader {
            constructor(data) {
                this.data = data;
                this.index = 0;
            }

            readBit() {
                return this.data[this.index++];
            }

            readNBits(n) {
                let bits = [];
                for (let i = 0; i < n; i++) {
                    bits.push(this.readBit());
                }
                return bits;
            }

            readByte() {
                let byte = 0;
                for (let i = 0; i < 8; i++) {
                    byte |= this.readBit() << (7 - i);
                }
                return byte;
            }

            readNBytes(n) {
                let bytes = [];
                for (let i = 0; i < n; i++) {
                    bytes.push(this.readByte());
                }
                return bytes;
            }

            readInt32() {
                let bytes = this.readNBytes(4);
                return new DataView(new Uint8Array(bytes).buffer).getInt32(0, false);
            }
        }

        const asyncFileReaderAsDataURL = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    resolve(e.target.result);
                };
                reader.onerror = (e) => {
                    reject(e);
                };
                reader.readAsDataURL(file);
            });
        };


        async function getStealthExif(src) {
            let time = performance.now();

            let canvas = document.createElement('canvas');
            let ctx = canvas.getContext('2d', {
                willReadFrequently: true,
                alpha: true
            });
            let img = new Image();
            img.src = src;

            await img.decode();

            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            let imageData = ctx.getImageData(0, 0, img.width, img.height);
            let lowestData = [];

            for (let x = 0; x < img.width; x++) {
                for (let y = 0; y < img.height; y++) {
                    let index = (y * img.width + x) * 4;
                    let a = imageData.data[index + 3];
                    lowestData.push(a & 1);
                }
            }

            console.log("Time taken: ", performance.now() - time, "ms");

            const magic = "stealth_pngcomp";
            const reader = new DataReader(lowestData);
            const readMagic = reader.readNBytes(magic.length);
            const magicString = String.fromCharCode.apply(null, readMagic);

            if (magic === magicString) {
                const dataLength = reader.readInt32();
                const gzipData = reader.readNBytes(dataLength / 8);
                const data = pako.ungzip(new Uint8Array(gzipData));
                const jsonString = new TextDecoder().decode(new Uint8Array(data));
                const json = JSON.parse(jsonString);
                return json;
            } else {
                console.log("Magic number not found.");
            }

            return null;
        }
    </script>
    <script>
        var app = new Vue({
            el: '#app',
            data: {
                preview: null,
                isPNG: true,
                hasMetadata: true,
                isNAIMetadata: true,
                rawPrompts: "",
                steps: 0,
                height: 0,
                width: 0,
                sampler: "",
                seed: 0,
                strength: 0,
                noise: 0,
                scale: 0,
                uc: "",
                software: "",
                source: "",
                title: "",
                cfg_rescale: 0,
                sm: "",
                sm_dyn: "",
                request_type: "",
                rawmetadata: "",
                reference_information_extracted_multiple: [],
                reference_strength_multiple: [],
                is_vibe: false,
                v4_prompts: {
                    isV4: false,
                    base_prompt: "",
                    base_negative_prompt: "",
                    characters: [] // { prompt: "", negative_prompt: "" }
                }
            },
            methods: {
                resetState: function() {
                    // Reset all data properties to their initial state
                    this.preview = null;
                    this.isPNG = true;
                    this.hasMetadata = true;
                    this.isNAIMetadata = true;
                    this.rawPrompts = "";
                    this.steps = 0;
                    this.height = 0;
                    this.width = 0;
                    this.sampler = "";
                    this.seed = 0;
                    this.strength = 0;
                    this.noise = 0;
                    this.scale = 0;
                    this.uc = "";
                    this.software = "";
                    this.source = "";
                    this.title = "";
                    this.cfg_rescale = 0;
                    this.sm = "";
                    this.sm_dyn = "";
                    this.request_type = "";
                    this.rawmetadata = "";
                    this.reference_information_extracted_multiple = [];
                    this.reference_strength_multiple = [];
                    this.is_vibe = false;
                    this.v4_prompts = {
                        isV4: false,
                        base_prompt: "",
                        base_negative_prompt: "",
                        characters: []
                    };
                },
                onFileChange: async function (e) {
                    this.resetState();
                    const files = e.target.files || e.dataTransfer.files;
                    if (files.length === 0) return;
                    
                    const file = files[0];
                    if (file.type !== 'image/png') {
                        this.isPNG = false;
                        this.hasMetadata = false;
                        this.isNAIMetadata = false;
                        return;
                    }

                    this.isPNG = true;
                    this.preview = URL.createObjectURL(file);

                    const exifmetadata = await this.getMetadata(file);
                    const src = await asyncFileReaderAsDataURL(file);
                    const stealthMetadata = await getStealthExif(src);

                    let metadata = {};
                    if (exifmetadata && exifmetadata.tEXt) {
                        metadata = { ...exifmetadata.tEXt };
                    }
                    if (stealthMetadata) {
                         // Merge, stealthMetadata has higher priority for NovelAI specific fields
                        metadata = { ...metadata, ...stealthMetadata };
                    }
                    
                    if (Object.keys(metadata).length === 0) {
                        this.hasMetadata = false;
                        this.isNAIMetadata = false;
                        return;
                    }

                    this.hasMetadata = true;
                    
                    if (metadata.Software === 'NovelAI' && metadata.Description && metadata.Comment) {
                        this.isNAIMetadata = true;
                        this.software = metadata.Software;
                        this.source = metadata.Source;
                        this.title = metadata.Title;
                        this.rawPrompts = metadata.Description;

                        let _comment;
                        try {
                           _comment = JSON.parse(metadata.Comment);
                        } catch(error) {
                            console.error("Failed to parse Comment JSON:", error);
                            this.isNAIMetadata = false;
                            this.rawmetadata = JSON.stringify(metadata, null, 2);
                            return;
                        }


                        // Populate common fields
                        this.steps = _comment.steps;
                        this.height = _comment.height;
                        this.width = _comment.width;
                        this.sampler = _comment.sampler;
                        this.seed = _comment.seed;
                        this.strength = _comment.strength;
                        this.noise = _comment.noise;
                        this.scale = _comment.scale;
                        this.uc = _comment.uc;
                        this.cfg_rescale = _comment.cfg_rescale;
                        this.sm = _comment.sm;
                        this.sm_dyn = _comment.sm_dyn;
                        this.request_type = _comment.request_type;
                        this.reference_information_extracted_multiple = _comment.reference_information_extracted_multiple || [];
                        this.reference_strength_multiple = _comment.reference_strength_multiple || [];
                        this.is_vibe = this.reference_information_extracted_multiple.length > 0 || this.reference_strength_multiple.length > 0;

                        // Check for V4 prompts
                        if (_comment.v4_prompt && _comment.v4_negative_prompt) {
                            this.v4_prompts.isV4 = true;
                            const v4p = _comment.v4_prompt.caption;
                            const v4n = _comment.v4_negative_prompt.caption;

                            this.v4_prompts.base_prompt = v4p.base_caption || "N/A";
                            this.v4_prompts.base_negative_prompt = v4n.base_caption || "N/A";
                            
                            const charCaptions = v4p.char_captions || [];
                            const negCharCaptions = v4n.char_captions || [];

                            const numChars = Math.max(charCaptions.length, negCharCaptions.length);

                            for (let i = 0; i < numChars; i++) {
                                const centers = charCaptions[i]?.centers;
                                let positionText = "N/A";
                                
                                // 检查 `centers` 是否是一个有效的数组
                                if (centers && Array.isArray(centers) && centers.length > 0) {
                                    // 将坐标对象数组格式化为字符串
                                    positionText = centers.map(c => `x: ${c.x}, y: ${c.y}`).join('; ');
                                } else if (centers) {
                                    // 为其他意外情况提供备用显示
                                    positionText = String(centers);
                                }
                                this.v4_prompts.characters.push({
                                    prompt: charCaptions[i]?.char_caption || "N/A",
                                    negative_prompt: negCharCaptions[i]?.char_caption || "N/A",
                                    position: positionText || "N/A",
                                });
                            }
                        } else {
                            this.v4_prompts.isV4 = false;
                        }

                    } else {
                        this.isNAIMetadata = false;
                        this.rawmetadata = JSON.stringify(metadata, null, 2);
                    }
                },
                getMetadata: function (file) {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.readAsArrayBuffer(file);
                        reader.onload = () => {
                            try {
                                const metadata = this.readMetadata(reader.result)
                                resolve(metadata)
                            } catch(e) {
                                console.error("Error reading metadata from PNG:", e);
                                resolve({}); // Resolve with empty object on error
                            }
                        };
                        reader.onerror = (err) => {
                             console.error("FileReader error:", err);
                             reject(err);
                        }
                    })
                },
                readMetadata: function (buffer) {
                    const result = {};
                    const chunks = this.extractChunks(buffer);
                    chunks.forEach(chunk => {
                        switch (chunk.name) {
                            case 'tEXt':
                                if (!result.tEXt) {
                                    result.tEXt = {};
                                }
                                // eslint-disable-next-line no-case-declarations
                                const textChunk = this.textDecode(chunk.data);
                                result.tEXt[textChunk.keyword] = textChunk.text;
                                break
                            case 'pHYs':
                                result.pHYs = {
                                    // Pixels per unit, X axis: 4 bytes (unsigned integer)
                                    "x": this.readUint32(chunk.data, 0),
                                    // Pixels per unit, Y axis: 4 bytes (unsigned integer)
                                    "y": this.readUint32(chunk.data, 4),
                                    "unit": chunk.data[8],
                                }
                                break
                            case 'iTXt':
                                if (!result.tEXt) {
                                    result.tEXt = {};
                                }
                                const textDecode = this.textDecode(chunk.data);
                                // console.log(textDecode);
                                // ヘッダーのいらない部分を削除
                                result.tEXt[textDecode.keyword] = textDecode.text.replaceAll("\x00", "")
                                break
                            case 'gAMA':
                            case 'cHRM':
                            case 'sRGB':
                            case 'IHDR':
                            case 'iCCP':
                            default:
                                result[chunk.name] = true;
                        }
                    })
                    return result;
                },
                extractChunks: function (_data) {
                    // from https://github.com/hughsk/png-chunks-extract
                    const data = new Uint8Array(_data)
                    if (data[0] !== 0x89) throw new Error('Invalid .png file header')
                    if (data[1] !== 0x50) throw new Error('Invalid .png file header')
                    if (data[2] !== 0x4E) throw new Error('Invalid .png file header')
                    if (data[3] !== 0x47) throw new Error('Invalid .png file header')
                    if (data[4] !== 0x0D) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')
                    if (data[5] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')
                    if (data[6] !== 0x1A) throw new Error('Invalid .png file header')
                    if (data[7] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')

                    let ended = false
                    const chunks = []
                    let idx = 8

                    const uint8 = new Uint8Array(4)
                    // const int32 = new Int32Array(uint8.buffer)
                    const uint32 = new Uint32Array(uint8.buffer)

                    while (idx < data.length) {
                        uint8[3] = data[idx++]
                        uint8[2] = data[idx++]
                        uint8[1] = data[idx++]
                        uint8[0] = data[idx++]
                        const length = uint32[0] + 4
                        const chunk = new Uint8Array(length)
                        chunk[0] = data[idx++]
                        chunk[1] = data[idx++]
                        chunk[2] = data[idx++]
                        chunk[3] = data[idx++]
                        const name = (
                            String.fromCharCode(chunk[0]) +
                            String.fromCharCode(chunk[1]) +
                            String.fromCharCode(chunk[2]) +
                            String.fromCharCode(chunk[3])
                        )

                        // The IHDR header MUST come first.
                        if (!chunks.length && name !== 'IHDR') {
                            throw new Error('IHDR header missing')
                        }

                        if (name === 'IEND') {
                            ended = true
                            chunks.push({
                                name,
                                data: new Uint8Array(0)
                            })

                            break
                        }

                        for (let i = 4; i < length; i++) {
                            chunk[i] = data[idx++]
                        }

                        uint8[3] = data[idx++]
                        uint8[2] = data[idx++]
                        uint8[1] = data[idx++]
                        uint8[0] = data[idx++]

                        const chunkData = new Uint8Array(chunk.buffer.slice(4))

                        chunks.push({
                            name,
                            data: chunkData
                        })
                    }

                    if (!ended) {
                        throw new Error('.png file ended prematurely: no IEND header was found')
                    }

                    return chunks
                },
                textDecode: function (data) {
                    if (data.data && data.name) {
                        data = data.data
                    }

                    let naming = true
                    let text = ''
                    let name = ''

                    for (let i = 0; i < data.length; i++) {
                        const code = data[i]
                        if (naming) {
                            if (code) {
                                name += String.fromCharCode(code)
                            } else {
                                naming = false
                            }
                        } else {
                            const text_decoder = new TextDecoder("utf-8");
                            const str = text_decoder.decode(Uint8Array.from(data.slice(i)).buffer);
                            text = str
                            break
                        }
                    }

                    return {
                        keyword: name,
                        text
                    }
                },
                readUint32: function (uint8array, offset) {
                    const byte1 = uint8array[offset++];
                    const byte2 = uint8array[offset++];
                    const byte3 = uint8array[offset++];
                    const byte4 = uint8array[offset];
                    return 0 | (byte1 << 24) | (byte2 << 16) | (byte3 << 8) | byte4;
                }
            }
        })
    </script>
</body>

</html>
